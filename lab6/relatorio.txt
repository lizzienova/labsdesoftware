1. No inicio do arquivo assembly, são definidos os dados globais: o vetor de inteiros e a string usada pelo printf. Foi definido um prólogo que por enquanto não sei explicar
mas chamamos de caixa preta. Logo depois, o registrador ebx é zerado, representando a variável i do código C, enquanto r12 recebe o endereço do vetor, 
funcionando como o ponteiro p. A partir daí, o loop é organizado por L1 e L2. m L1, é feita uma verificação: se ebx já chegou a 4, o programa sai do loop; caso contrário,
o valor apontado por r12 é movido para eax e enviado para printf. Depois de imprimir, ebx é incrementado em 1 e r12 "anda" 4 bytes para passar pro próximo elemento do vetor.
O salto condicional retorna pro início de L1, repetindo o processo até que ebx chegue a 4. Em L2, há uma outra caixa preta que ainda nao consigo definir

2. Zerei o registrador %eax pra usar ele como acumulador da soma. Retirei o printf já que ele não é mais necessário e coloquei a operação de soma no lugar 
addl (%r12), %eax   ; sum += *p. Depois o código começa como o anterior

3. O objetivo da modificação proposta no programa em C era exibir apenas os elementos pares de um array de inteiros.
Pra isso, ao traduzir o código para Assembly, foi necessário implementar uma linha que fizesse esse teste. 
Em vez de usar a operação de módulo (% 2), que é mais custosa, usei uma operação bit a bit.

4. Na terceira modificação, o array foi trocado para um de char. Fiz duas alterações: a aritmética de ponteiros foi modificada,
trocando addq $4, %r12 por addq $1, %r12 para andar só 1 byte. 


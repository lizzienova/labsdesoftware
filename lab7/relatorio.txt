1. O programa percorre o array de chars e imprime cada elemento convertendo para ASCII. Na versão do assembly, primeiro são declarados o vetor de bytes e as duas strings
que o printf usará. Depois do prólogo, o endereço do array é colocado em %r12, e o rótulo L1 funciona como um laço, verifica se o byte atual é zero; se for, vai para L2, onde apenas imprime o \n e segue para a finalização do programa.
Caso contrário, o byte apontado por %r12 é extendido, passado para o printf como %c e depois %r12 é incrementado para ir pro próximo elemento. 

2. O código original imprimia todos os caracteres enquanto o ponteiro pc não encontrava o byte 0. 
A modificação aplicada foi:
    if (*pc != 123 && *pc != 125)
        printf("%c", *pc);
exercendo um mecanismo de filtro no loop. Então, a segunda condição só é testada quando a primeira é verdadeira.

3. No Assembly, usei o registrador %ebx para a variável do laço e %eax para armazenar o resultado do quadrado.
O cálculo do quadrado foi feito com a instrução imull %ebx, %eax, e cada valor foi impresso chamando printf com a string.
ambém implementei o incremento e o teste de limite do laço em Assembly para percorrer apenas de 1 a 10.

4. No meu código, implementei diretamente a operação de indexação calculando o endereço de cada elemento usando a fórmula:end(a) + i*sizeof(T)
Primeiro, incializei os registradores que representam as variáveis do código em C, depois implementei o loop comparando
o registrador de “i” com 4, e saltando para o final quando a condição fosse verdadeira.
Dentro do loop vacilei nums[i] copiando i para %r13, multiplicando por 4, e somei ao endereço base 
do array. Assim, carreguei o valor do elemento e somei ao acumulador s.
Depois de percorrer o loop, coloquei o valor de retorno em eax e chamei printf para imprimir a soma. 
